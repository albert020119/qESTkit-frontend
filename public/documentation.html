<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Quantum Simulator Documentation</title>
  <link rel="stylesheet" href="documentation.css" />
</head>
<body>
  <div class="wrapper">
    <div class="sidebar">
      <h2>Docs</h2>

      <div>
        <a href="#" onclick="showSection('help')">Help</a>
        <div class="indent">
          <a href="#" onclick="showSection('simulate')">• How to simulate circuit</a>
          <a href="#" onclick="showSection('noisy')">• Noisy Mode</a>
        </div>
      </div>

      <div>
        <a href="#" onclick="showSection('theory')">Theoretical Documentation</a>
        <div class="indent">
          <a href="#" onclick="showSection('qubit')">• What is a Qubit?</a>
          <a href="#" onclick="showSection('gates')">• Quantum Gates</a>
          <a href="#" onclick="showSection('algorithms')">• Common Algorithms</a>
        </div>
      </div>
    </div>

    <div class="content">
      <div id="help" class="section">
        <h1>Welcome to the Documentation</h1>
        <p>Select a section from the sidebar.</p>
      </div>

      <div id="simulate" class="section" style="display:none">
        <h1>How to simulate circuit</h1>
        <p>Write your circuit code in the provided editor and press the simulate button to see the results.</p>
      </div>

      <div id="noisy" class="section" style="display:none">
        <h1>Noisy Mode</h1>
        <p>Enabling Noisy Mode will simulate real-world imperfections using adjustable error rates.</p>
      </div>

      <div id="qubit" class="section" style="display:none">
  <h1>What is a Qubit?</h1>
  <p>
    A <strong>qubit</strong> (quantum bit) is the basic unit of quantum information. Unlike a classical bit which can be either <code>0</code> or <code>1</code>,
    a qubit can exist in a <em>superposition</em> of both states:
  </p>

  <pre>|ψ⟩ = α|0⟩ + β|1⟩</pre>

  <p>
    Here, α and β are complex numbers representing probability amplitudes. The probabilities of measuring |0⟩ and |1⟩ are given by:
  </p>
  <pre>Pr(0) = |α|², Pr(1) = |β|²,  where |α|² + |β|² = 1</pre>

  <h2>Superposition</h2>
  <p>
    Superposition means the qubit is "in both states" until it is measured. For example, with equal amplitudes:
  </p>
  <pre>|ψ⟩ = (1/√2)|0⟩ + (1/√2)|1⟩</pre>
  <p>
    The measurement outcome is random, but with 50% chance for either 0 or 1.
  </p>

  <h2>Bloch Sphere</h2>
  <p>
    Any single qubit pure state can be represented as a point on the Bloch sphere:
  </p>
  <pre>|ψ⟩ = cos(θ/2)|0⟩ + e^{iφ}sin(θ/2)|1⟩</pre>
  <p>
    Where θ and φ are angles in 3D space. This is a powerful geometric way to understand qubit transformations.
  </p>

  <h2>Entanglement</h2>
  <p>
    Qubits can also be entangled. In entangled states, measuring one qubit affects the state of the other, no matter how far apart they are.
  </p>
  <pre>Example: (|00⟩ + |11⟩) / √2</pre>
</div>


      <div id="gates" class="section" style="display:none">
  <h1>Quantum Gates</h1>
  <p>
    Quantum gates are unitary operations that manipulate the state of one or more qubits.
    They are reversible and correspond to matrices that rotate the qubit on the Bloch sphere.
  </p>

  <h2>Single-Qubit Gates</h2>

  <h3>Hadamard (H)</h3>
  <p>Places a qubit into equal superposition:</p>
  <pre>
H = (1/√2) [ [1,  1],
             [1, -1] ]
  </pre>
  <p>
    H|0⟩ = (|0⟩ + |1⟩)/√2  H|1⟩ = (|0⟩ - |1⟩)/√2
  </p>

  <h3>Pauli Gates</h3>
  <ul>
    <li><strong>X gate</strong>: Bit flip (like classical NOT)</li>
    <pre>X = [ [0, 1], [1, 0] ]</pre>

    <li><strong>Y gate</strong>: Bit and phase flip</li>
    <pre>Y = [ [0, -i], [i, 0] ]</pre>

    <li><strong>Z gate</strong>: Phase flip</li>
    <pre>Z = [ [1, 0], [0, -1] ]</pre>
  </ul>

  <h3>Phase Gates</h3>
  <ul>
    <li><strong>S gate</strong> (√Z): Adds a 90° phase to |1⟩</li>
    <li><strong>T gate</strong> (4th root of Z): Adds a 45° phase</li>
  </ul>

  <h3>Rotation Gates</h3>
  <p>These rotate the qubit around a Bloch axis by angle θ:</p>
  <ul>
    <li>Rx(θ): around X-axis</li>
    <li>Ry(θ): around Y-axis</li>
    <li>Rz(θ): around Z-axis</li>
  </ul>

  <h2>Two-Qubit Gates</h2>

  <h3>CNOT (Controlled-NOT)</h3>
  <p>
    Flips the target qubit if the control qubit is |1⟩. Used to create entanglement.
  </p>

  <h3>SWAP</h3>
  <p>
    Swaps the states of two qubits.
  </p>

  <h3>Controlled Gates</h3>
  <p>
    Many gates can be made conditional (e.g., Controlled-Z, Controlled-Rz).
  </p>

  <h2>Measurement (Not a gate)</h2>
  <p>
    Collapses a qubit to |0⟩ or |1⟩ with probabilities based on its amplitude.
    This is the only non-reversible operation in quantum computing.
  </p>
</div>

<div id="algorithms" class="section" style="display:none">
  <h1>Common Quantum Algorithms</h1>

  <h2>Grover’s Search Algorithm</h2>
  <p>
    Grover’s algorithm is used to search an unsorted database of N items in only <strong>√N</strong> queries, compared to N/2 queries classically on average.
    It uses an <em>oracle</em> to mark the solution and then amplifies its probability through a process called <strong>amplitude amplification</strong>.
    Although it's not exponential speedup, it's significant for certain types of search problems.
  </p>
  <p>
    A typical Grover circuit includes Hadamard gates to create superposition, oracle function to flip the phase of the correct answer, and a diffusion operator to amplify it.
  </p>

  <h2>Quantum Teleportation</h2>
  <p>
    Quantum teleportation allows a qubit's quantum state to be transmitted from one location to another <em>without physically sending the qubit itself</em>.
    It requires a pair of entangled qubits shared between the sender (Alice) and the receiver (Bob).
  </p>
  <p>
    Alice performs a Bell-state measurement on her qubit and the state she wants to teleport, then sends the two classical bits of result to Bob.
    Using those bits, Bob applies Pauli operations (X and/or Z) to reconstruct the original state on his end.
  </p>
  <p>
    Note: Teleportation <strong>does not clone</strong> the state — the original is destroyed when measured.
  </p>

  <h2>BB84 Protocol</h2>
  <p>
    The BB84 protocol is the first quantum key distribution (QKD) scheme. It lets two parties (traditionally Alice and Bob) generate a shared secret key over an insecure quantum channel.
  </p>
  <p>
    Alice sends qubits in one of two bases (e.g., rectilinear or diagonal), chosen randomly. Bob measures them using a random basis. They later publicly compare which bases they used, discarding mismatches.
    The remaining bits — when bases matched — form a <strong>raw key</strong>.
  </p>
  <p>
    BB84’s security relies on the <em>no-cloning theorem</em> and the fact that any eavesdropping (by Eve) introduces detectable errors.
  </p>

  <h2>Shor’s Algorithm</h2>
  <p>
    Shor’s algorithm efficiently factors large integers, which threatens classical cryptographic schemes like RSA that rely on the hardness of factorization.
    It uses the quantum Fourier transform (QFT) to find the <em>period</em> of a modular exponential function, which reveals a factor of the number.
  </p>
  <p>
    Classically, factoring a number N takes sub-exponential time. Shor’s algorithm reduces it to polynomial time: O((log N)^3), which is exponentially faster.
    Its impact is foundational in post-quantum cryptography research and the push for quantum-safe encryption.
  </p>
</div>


    </div>
  </div>

  <script>
    function showSection(id) {
      document.querySelectorAll('.section').forEach(s => s.style.display = 'none');
      document.getElementById(id).style.display = 'block';
    }
  </script>
</body>
</html>
